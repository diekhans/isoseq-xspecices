#!/usr/bin/env python3
import sys
from os import path as osp
import argparse
import json
from collections import namedtuple
import twobitreader
sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))

from pycbio.hgdata import dnaOps
from pycbio.hgdata.frame import Frame
from pycbio.hgdata.coords import Coords
from pycbio.sys import fileOps
from pycbio.sys.objDict import ObjDict
from xspecies.data import (Region, RCoords, MappedTranscript, MappedExon, mappedTranscriptToBed,
                           getGenomeTwoBit, RegionSeq, loadMappings)

# src tcoords -> mapping tcoords -> mapping qcoords -> src qcoords -> src tcoords

def parseArgs():
    usage = """Generate annotation JSON file for exchange"""
    parser = argparse.ArgumentParser(description=usage)
    parser.add_argument('srcGenome')
    parser.add_argument('srcPsl')
    parser.add_argument('srcGenePred')
    parser.add_argument('srcMeta')
    parser.add_argument('mappedGenome')
    parser.add_argument('mappedPsl')
    parser.add_argument('mappedGenePred',
                        help="produced by transMapPslToGenePred -noBlockMerge")
    parser.add_argument('--annotBed')
    parser.add_argument('annotJson')
    return parser.parse_args()

class MappedAlnBlk(namedtuple("MappedAlnBlk", ("src", "mapped", "rna", "frame"))):
    "genomic (target alignments) of exons"
    pass

def getSubCoords(blk, qStart, qEnd):
    if blk.psl.qStrand == '-':
        qStart, qEnd = dnaOps.reverseCoords(qStart, qEnd, blk.psl.qSize)
    tStart = blk.tStart + (qStart - blk.qStart)
    tEnd = tStart + (qEnd - qStart)
    return Coords(blk.psl.tName, tStart, tEnd, blk.psl.tStrand, blk.psl.tSize)

def qOrientCoords(psl, coords):
    if psl.qStrand == '-':
        coords = coords.reverse()
    return coords

def getSrcSubrangeFrame(srcExon, region):
    if srcExon.frame < 0:
        return None
    cds = Region(srcExon.gene.cdsStart, srcExon.gene.cdsEnd)
    exonCds = Region(srcExon.start, srcExon.end).intersect(cds)
    regionCds = exonCds.intersect(region)
    if len(regionCds) == 0:
        return None
    elif srcExon.gene.strand == '+':
        return Frame(srcExon.frame) + (regionCds.start - srcExon.start)
    else:
        return Frame(srcExon.frame) + (srcExon.end - regionCds.end)

def _blkIntersect(srcBlk, srcExon, mappedBlk, mappedExon):
    """overlap has been determine by query coords"""

    srcAbsCoords = getSubCoords(srcBlk, mappedBlk.qStartPlus, mappedBlk.qEndPlus)
    frame = getSrcSubrangeFrame(srcExon, srcAbsCoords)
    srcCoords = qOrientCoords(srcBlk.psl,srcAbsCoords)
    mappedCoords = qOrientCoords(mappedBlk.psl,
                                 Coords(mappedBlk.psl.tName, mappedBlk.tStart, mappedBlk.tEnd, mappedBlk.psl.tStrand, mappedBlk.psl.tSize))
    rnaCoords = qOrientCoords(mappedBlk.psl,
                              Coords(mappedBlk.psl.qName, mappedBlk.qStart, mappedBlk.qEnd, mappedBlk.psl.qStrand, mappedBlk.psl.qSize))
    return MappedAlnBlk(srcCoords, mappedCoords, rnaCoords, frame)

def srcBlkToMappedBlks(srcBlk, srcExon, mappedPsl, mappedGp):
    """returns src block mappings as a list of MappedAlnBlk objs.
    Results will be strand-specific coordinates in direction of transcriptions.
    """
    alnBlks = []
    # find mapped blocks associate with src exons
    for iMapped in range(len(mappedPsl.blocks)):
        mappedBlk = mappedPsl.blocks[iMapped]
        if (srcBlk.qStartPlus < mappedBlk.qEndPlus) and (srcBlk.qEndPlus > mappedBlk.qStartPlus):
            alnBlks.append(_blkIntersect(srcBlk, srcExon, mappedBlk, mappedGp.exons[iMapped]))
    alnBlks.sort(key=lambda a: (a.rna.start,))
    return alnBlks

def addDnaAlnBlock(srcRegionSeq, mappedRegionSeq, srcPrev, mappedPrev,
                   alnBlk, srcParts, mappedParts):
    # add unaligned on both sized
    if (alnBlk.src.start > srcPrev):
        srcParts.append(srcRegionSeq.get(alnBlk.src.adjust(start=srcPrev, end=alnBlk.src.start)))
        mappedParts.append((alnBlk.src.start - srcPrev) * '-')
    if (alnBlk.mapped.start > mappedPrev):
        mappedParts.append(mappedRegionSeq.get(alnBlk.mapped.adjust(start=mappedPrev, end=alnBlk.mapped.start)))
        srcParts.append((alnBlk.mapped.start - mappedPrev) * '-')

    srcParts.append(srcRegionSeq.get(alnBlk.src))
    mappedParts.append(mappedRegionSeq.get(alnBlk.mapped))

def _calcIdentCover(src, mapped):
    alnCnt = matchCnt = 0
    srcCnt = srcAligned = 0
    for cs, cm in zip(src, mapped):
        if (cs != '-') and (cm != '-'):
            alnCnt += 1
            if cs.upper() == cm.upper():
                matchCnt += 1
        if cs != '-':
            srcCnt += 1
            if cm != '-':
                srcAligned += 1
    return (round(matchCnt / alnCnt if alnCnt > 0 else 0.0, 3),
            round(srcAligned / srcCnt if srcCnt > 0 else 0.0, 3))

class SeqAlign(ObjDict):
    def __init__(self, src, mapped):
        self.src = src
        self.mapped = mapped
        self.identity, self.coverage = _calcIdentCover(src, mapped)

def buildDnaAln(srcGenomeSeqs, mappedGenomeSeqs, alnBlks):
    alnBlk0 = alnBlks[0]
    alnBlkN = alnBlks[-1]
    srcRegionSeq = RegionSeq(srcGenomeSeqs,
                             Coords(alnBlk0.src.name, alnBlk0.src.start, alnBlkN.src.end, alnBlk0.src.strand, alnBlk0.src.size))
    mappedRegionSeq = RegionSeq(mappedGenomeSeqs,
                                Coords(alnBlk0.mapped.name, alnBlk0.mapped.start, alnBlkN.mapped.end, alnBlk0.mapped.strand, alnBlk0.mapped.size))

    srcParts = []
    mappedParts = []
    srcPrev = alnBlk0.src.start
    mappedPrev = alnBlk0.mapped.start
    for alnBlk in alnBlks:
        addDnaAlnBlock(srcRegionSeq, mappedRegionSeq, srcPrev, mappedPrev,
                       alnBlk, srcParts, mappedParts)
        srcPrev = alnBlk.src.end
        mappedPrev = alnBlk.mapped.end
    srcAln = "".join(srcParts)
    mappedAln = "".join(mappedParts)
    assert len(srcAln) == len(mappedAln), f"srcAln={len(srcAln)} mappedAln={len(mappedAln)}"
    return SeqAlign(srcAln, mappedAln)

def buildProtAln(srcGenomeSeqs, mappedGenomeSeqs, alnBlks, dnaAlign):
    pass

def pslBlkToRegion(blk):
    return Region(blk.tStart, blk.tEnd)

def pslToRCoords(psl):
    return RCoords(psl.tName, psl.tStart, psl.tEnd, psl.qStrand)

def mkSrcExonId(srcGenome, srcExon):
    return "{}.{}:{}-{}".format(srcGenome, srcExon.gene.chrom, srcExon.start, srcExon.end)

def buildMappedExon(srcGenome, srcGenomeSeqs, mappedGenomeSeqs, srcExonNum, srcBlk, srcExon, alnBlks, mappedGp):
    mappedRegion = Region(alnBlks[0].mapped.start, alnBlks[-1].mapped.end)
    mappedBases = sum([len(b.mapped) for b in alnBlks])
    dnaAlign = buildDnaAln(srcGenomeSeqs, mappedGenomeSeqs, alnBlks)
    cds = Region(srcExon.gene.cdsStart, srcExon.gene.cdsEnd).intersect(Region(srcExon.start, srcExon.end))
    return MappedExon(mkSrcExonId(srcGenome, srcExon), srcExonNum,
                      pslBlkToRegion(srcBlk), len(srcExon),
                      mapped=mappedRegion, mappedBases=mappedBases,
                      cds=cds, frame=Frame.fromFrame(srcExon.frame),
                      dnaAlign=dnaAlign)

def printAlnBlks(mappedTrans, alnBlks):
    print("====", mappedTrans.srcPsl.qName, mappedTrans.srcPsl.strand, "->",
          mappedTrans.mappedPsl.qName, mappedTrans.mappedPsl.strand,
          "====", file=sys.stderr)
    for ab in alnBlks:
        print(f"alnBlk: src={ab.src}[{ab.src.strand}]",
              f"map={ab.mapped}[{ab.mapped.strand}]",
              f"rna={ab.rna}[{ab.rna.strand}]",
              f"frame={ab.frame}", file=sys.stderr)
    print(file=sys.stderr)

def processExon(srcGenome, srcGenomeSeqs, mappedGenomeSeqs, srcExonNum, srcBlk, srcExon, mappedTrans):
    alnBlks = srcBlkToMappedBlks(srcBlk, srcExon, mappedTrans.mappedPsl, mappedTrans.mappedGp)
    # printAlnBlks(mappedTrans, alnBlks)
    if len(alnBlks) == 0:
        return MappedExon(mkSrcExonId(srcGenome, srcExon), srcExonNum, pslBlkToRegion(srcBlk), len(srcExon))
    else:
        return buildMappedExon(srcGenome, srcGenomeSeqs, mappedGenomeSeqs, srcExonNum, srcBlk, srcExon, alnBlks, mappedTrans.mappedGp)

def getCds(mappedGp):
    if mappedGp.txStart < mappedGp.txEnd:
        return Region(mappedGp.txStart, mappedGp.txEnd)
    else:
        return None

def processTrans(srcGenome, srcGenomeSeqs, mappedGenome, mappedGenomeSeqs, mappedTrans):
    exons = []
    # traverse in RNA direction
    iExonIter = range(len(mappedTrans.srcPsl.blocks))
    if mappedTrans.srcPsl.qStrand == '-':
        iExonIter = reversed(iExonIter)

    srcExonNum = 1
    for iSrcExon in iExonIter:
        exons.append(processExon(srcGenome, srcGenomeSeqs, mappedGenomeSeqs, srcExonNum, mappedTrans.srcPsl.blocks[iSrcExon],
                                 mappedTrans.srcGp.exons[iSrcExon], mappedTrans))
        srcExonNum += 1

    srcMeta = mappedTrans.srcMeta
    mappedTrans = MappedTranscript(srcGenome, mappedTrans.srcPsl.qName, mappedGenome, mappedTrans.mappedPsl.qName, pslToRCoords(mappedTrans.srcPsl), pslToRCoords(mappedTrans.mappedPsl),
                                   srcMeta.geneId, srcMeta.geneName, srcMeta.geneType, srcMeta.transcriptName, srcMeta.transcriptType,
                                   getCds(mappedTrans.mappedGp), exons)
    return mappedTrans

def mappedAlignToAnnot(srcGenome, mappedGenome, mappedTranses):
    srcGenomeSeqs = twobitreader.TwoBitFile(getGenomeTwoBit(srcGenome))
    mappedGenomeSeqs = twobitreader.TwoBitFile(getGenomeTwoBit(mappedGenome))

    mappedAnnots = []
    for mappedTrans in mappedTranses:
        mappedAnnots.append(processTrans(srcGenome, srcGenomeSeqs,
                                         mappedGenome, mappedGenomeSeqs,
                                         mappedTrans))
    return mappedAnnots

def writeAnnotBed(mappedAnnots, bedFh):
    for ma in mappedAnnots:
        bed = mappedTranscriptToBed(ma)
        if bed is not None:
            bed.write(bedFh)

def main(opts):
    mappedTranses = loadMappings(opts.srcPsl, opts.srcGenePred, opts.srcMeta,
                                 opts.mappedPsl, opts.mappedGenePred)
    mappedAnnots = mappedAlignToAnnot(opts.srcGenome, opts.mappedGenome,
                                      mappedTranses)

    with fileOps.opengz(opts.annotJson, "w") as fh:
        json.dump(mappedAnnots, fh, indent=4)

    if opts.annotBed is not None:
        with fileOps.opengz(opts.annotBed, "w") as fh:
            writeAnnotBed(mappedAnnots, fh)


main(parseArgs())
