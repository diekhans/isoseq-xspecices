#!/usr/bin/env python3
import sys
from os import path as osp
import argparse
import json
from collections import namedtuple
import twobitreader
sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))

from pycbio.hgdata import dnaOps
from pycbio.hgdata.frame import Frame
from pycbio.hgdata.coords import Coords
from pycbio.sys import fileOps
from pycbio.sys.objDict import ObjDict
from Bio.Seq import Seq
from xspecies.data import (Region, RCoords, MappedTranscript, MappedExon, mappedTranscriptToBed,
                           getGenomeTwoBit, loadMappings)

def prerr(*args, **kwargs):
    print(*args, **kwargs, file=sys.stderr)

# src tcoords -> mapping tcoords -> mapping qcoords -> src qcoords -> src tcoords

def parseArgs():
    usage = """Generate annotation JSON file for exchange"""
    parser = argparse.ArgumentParser(description=usage)
    parser.add_argument('srcGenome')
    parser.add_argument('srcPsl')
    parser.add_argument('srcGenePred')
    parser.add_argument('srcMeta')
    parser.add_argument('mappedGenome')
    parser.add_argument('mappedPsl')
    parser.add_argument('mappedGenePred',
                        help="produced by transMapPslToGenePred -noBlockMerge")
    parser.add_argument('--annotBed')
    parser.add_argument('annotJson')
    return parser.parse_args()

class MappedAlnBlk(namedtuple("MappedAlnBlk", ("src", "mapped", "rna", "frame"))):
    """coordinates exons blocks, in transcription order, which means genome
    might be negative strand coordinates"""

    @staticmethod
    def _fmt(c):
        return f"{c.name}:{c.start}-{c.end}[{c.strand}]"

    def __str__(self):
        return ("alnBlk rna:  " + self._fmt(self.rna) + '\n'
                "       src:  " + self._fmt(self.src) + '\n'
                "       map:  " + self._fmt(self.mapped))

def pslCoords(psl):
    return Coords(psl.tName, psl.tStart, psl.tEnd, psl.qStrand, psl.tSize)

def getCds(gp):
    return Region(gp.txStart, gp.txEnd)

def getCdsCoords(psl, gp):
    return Coords(gp.chrom, gp.txStart, gp.txEnd, gp.strand, psl.tSize)

def getSubCoords(blk, qStartPos, qEndPos):
    if blk.psl.qStrand == '-':
        qStartPos, qEndPos = dnaOps.reverseCoords(qStartPos, qEndPos, blk.psl.qSize)
    tStart = blk.tStart + (qStartPos - blk.qStart)
    tEnd = tStart + (qEndPos - qStartPos)
    return Coords(blk.psl.tName, tStart, tEnd, blk.psl.qStrand, blk.psl.tSize)

def getSrcSubrangeFrame(srcBlk, srcExon, srcCoords):
    if srcExon.frame < 0:
        return None
    regionCds = getCdsCoords(srcBlk.psl, srcExon.gene).intersect(srcCoords)
    if len(regionCds) == 0:
        return None
    elif srcExon.gene.strand == '+':
        return Frame(srcExon.frame) + (regionCds.start - srcExon.start)
    else:
        return Frame(srcExon.frame) + (srcExon.end - regionCds.end)

def _blkIntersect(srcBlk, srcExon, mappedBlk, mappedExon):
    """overlap has been determine by query coords"""
    srcCoords = getSubCoords(srcBlk, mappedBlk.qStartPlus, mappedBlk.qEndPlus)
    frame = getSrcSubrangeFrame(srcBlk, srcExon, srcCoords)
    mappedCoords = Coords(mappedBlk.psl.tName, mappedBlk.tStart, mappedBlk.tEnd, mappedBlk.psl.qStrand, mappedBlk.psl.tSize)
    rnaCoords = Coords(mappedBlk.psl.qName, mappedBlk.qStart, mappedBlk.qEnd, '+', mappedBlk.psl.qSize)
    return MappedAlnBlk(srcCoords, mappedCoords, rnaCoords, frame)

def srcBlkToMappedBlks(srcBlk, srcExon, mappedPsl, mappedGp):
    """returns src block mappings as a list of MappedAlnBlk objs.
    Results will be strand-specific coordinates in direction of transcriptions.
    """
    alnBlks = []
    # find mapped blocks associate with src exons
    for iMapped in range(len(mappedPsl.blocks)):
        mappedBlk = mappedPsl.blocks[iMapped]
        if (srcBlk.qStartPlus < mappedBlk.qEndPlus) and (srcBlk.qEndPlus > mappedBlk.qStartPlus):
            alnBlks.append(_blkIntersect(srcBlk, srcExon, mappedBlk, mappedGp.exons[iMapped]))
    alnBlks.sort(key=lambda a: (a.rna.start,))
    return alnBlks

def _calcIdentCover(src, mapped):
    alnCnt = matchCnt = 0
    srcCnt = srcAligned = 0
    for cs, cm in zip(src, mapped):
        if (cs != '-') and (cm != '-'):
            alnCnt += 1
            if cs.upper() == cm.upper():
                matchCnt += 1
        if cs != '-':
            srcCnt += 1
            if cm != '-':
                srcAligned += 1
    return (round(matchCnt / alnCnt if alnCnt > 0 else 0.0, 3),
            round(srcAligned / srcCnt if srcCnt > 0 else 0.0, 3))

class SeqAlign(ObjDict):
    def __init__(self, src, mapped, *, inclCover=True):
        self.src = src
        self.mapped = mapped
        self.identity, coverage = _calcIdentCover(src, mapped)
        if inclCover:
            self.coverage = coverage

    def __len__(self):
        return len(self.src)

    @staticmethod
    def fromParts(srcParts, mappedParts, *, inclCover=True):
        srcAln = "".join(srcParts)
        mappedAln = "".join(mappedParts)
        assert len(srcAln) == len(mappedAln), f"srcAln={len(srcAln)} mappedAln={len(mappedAln)}"
        return SeqAlign(srcAln, mappedAln, inclCover=inclCover)

def getSeq(seqreader, coords):
    seq = seqreader[coords.name][coords.start:coords.end]
    if coords.strand == '-':
        seq = dnaOps.reverseComplement(seq)
    return seq

def addDnaAlnBlock(srcGenomeSeqs, mappedGenomeSeqs, srcPrev, mappedPrev,
                   alnBlk, srcParts, mappedParts):
    # add unaligned on both sides
    if (alnBlk.src.start > srcPrev):
        s = alnBlk.src.adjust(start=srcPrev, end=alnBlk.src.start)
        srcParts.append(getSeq(srcGenomeSeqs, s))
        mappedParts.append((alnBlk.src.start - srcPrev) * '-')
    if (alnBlk.mapped.start > mappedPrev):
        m = alnBlk.mapped.adjust(start=mappedPrev, end=alnBlk.mapped.start)
        mappedParts.append(getSeq(mappedGenomeSeqs, m))
        srcParts.append((alnBlk.mapped.start - mappedPrev) * '-')

    srcParts.append(getSeq(srcGenomeSeqs, alnBlk.src))
    mappedParts.append(getSeq(mappedGenomeSeqs, alnBlk.mapped))

def buildDnaAln(srcGenomeSeqs, mappedGenomeSeqs, alnBlks):
    srcParts = []
    mappedParts = []
    srcPrev = alnBlks[0].src.start
    mappedPrev = alnBlks[0].mapped.start
    for alnBlk in alnBlks:
        addDnaAlnBlock(srcGenomeSeqs, mappedGenomeSeqs, srcPrev, mappedPrev, alnBlk, srcParts, mappedParts)
        srcPrev = alnBlk.src.end
        mappedPrev = alnBlk.mapped.end
    return SeqAlign.fromParts(srcParts, mappedParts)

def addProtAlnBlock(srcCds, dnaAlign, iAln, alnBlk, srcParts, mappedParts):
    blkCds = srcCds.intersect(alnBlk.src)
    cdsOff = blkCds.start - alnBlk.src.start
    phase = alnBlk.frame.toPhase()
    iAln += cdsOff + phase
    nBases = len(blkCds) - phase
    nBases -= nBases % 3
    prerr(64 * "-")
    prerr(str(alnBlk))
    prerr("mapped", alnBlk.mapped)
    prerr("fr", alnBlk.frame, "ph", phase, "ialn", iAln, "size", nBases)
    prerr(dnaAlign.src[iAln:iAln + nBases])
    prerr(dnaAlign.mapped[iAln:iAln + nBases])
    prerr(str(Seq(dnaAlign.src[iAln:iAln + nBases]).translate()))
    prerr(str(Seq(dnaAlign.mapped[iAln:iAln + nBases]).translate()))
    srcParts.append(str(Seq(dnaAlign.src[iAln:iAln + nBases]).translate()))
    mappedParts.append(str(Seq(dnaAlign.mapped[iAln:iAln + nBases]).translate()))


def buildProtAln(srcExon, alnBlks, dnaAlign):
    # for now, this drops codons split across gaps
    srcCds = Coords(srcExon.gene.name, srcExon.gene.cdsStart, srcExon.gene.cdsEnd, srcExon.gene.strand, alnBlks[0].src.size)
    if alnBlks[0].src.strand != alnBlks[0].srcStrand:
        srcCds = srcCds.reverse()
    srcParts = []
    mappedParts = []
    iAln = 0
    for alnBlk in alnBlks:
        if (len(alnBlk.src) == len(alnBlk.mapped)) and (alnBlk.frame is not None):
            addProtAlnBlock(srcCds, dnaAlign, iAln, alnBlk, srcParts, mappedParts)
        iAln += max(len(alnBlk.src), len(alnBlk.mapped))  # one side or both have bases

    protAln = SeqAlign.fromParts(srcParts, mappedParts, inclCover=False)
    if len(protAln) == 0:
        return None
    else:
        return protAln

def pslBlkToRegion(blk):
    return Region(blk.tStart, blk.tEnd)

def pslToRCoords(psl):
    return RCoords(psl.tName, psl.tStart, psl.tEnd, psl.qStrand)

def mkSrcExonId(srcGenome, srcExon):
    return "{}.{}:{}-{}".format(srcGenome, srcExon.gene.chrom, srcExon.start, srcExon.end)

def buildMappedExon(srcGenome, srcGenomeSeqs, mappedGenomeSeqs, srcExonNum, srcBlk, srcExon, mappedPsl, mappedGp, alnBlks):
    mappedRegion = Region(alnBlks[0].mapped.start, alnBlks[-1].mapped.end)
    mappedBases = sum([len(b.mapped) for b in alnBlks])
    dnaAlign = buildDnaAln(srcGenomeSeqs, mappedGenomeSeqs, alnBlks)
    protAlign = None
    #protAlign = buildProtAln(srcExon, alnBlks, dnaAlign)
    srcCds = Region(srcExon.gene.cdsStart, srcExon.gene.cdsEnd).intersect(Region(srcExon.start, srcExon.end))
    mappedCds = Region(mappedGp.cdsStart, mappedGp.cdsEnd).intersect(mappedRegion)
    return MappedExon(mkSrcExonId(srcGenome, srcExon), srcExonNum,
                      pslBlkToRegion(srcBlk), len(srcExon),
                      mapped=mappedRegion, mappedBases=mappedBases,
                      srcCds=srcCds, mappedCds=mappedCds, frame=Frame.fromFrame(srcExon.frame),
                      dnaAlign=dnaAlign, protAlign=protAlign)

def printAlnBlks(srcPsl, mappedPsl, alnBlks):
    prerr(">>>>",
          srcPsl.qName, repr(pslCoords(srcPsl)),
          "\n     ->",
          mappedPsl.qName, repr(pslCoords(mappedPsl)),
          "<<<<")
    for ab in alnBlks:
        prerr(repr(ab))
    prerr()

def processExon(srcGenome, srcGenomeSeqs, mappedGenomeSeqs, srcExonNum, srcBlk, srcExon, mappedPsl, mappedGp):
    alnBlks = srcBlkToMappedBlks(srcBlk, srcExon, mappedPsl, mappedGp)
    #printAlnBlks(srcBlk.psl, mappedPsl, alnBlks)
    if len(alnBlks) == 0:
        return MappedExon(mkSrcExonId(srcGenome, srcExon), srcExonNum, pslBlkToRegion(srcBlk), len(srcExon))
    else:
        return buildMappedExon(srcGenome, srcGenomeSeqs, mappedGenomeSeqs, srcExonNum, srcBlk, srcExon, mappedPsl, mappedGp, alnBlks)

def processTrans(srcGenome, srcGenomeSeqs, mappedGenome, mappedGenomeSeqs, mappedData):
    exons = []
    # traverse in RNA direction
    iExonIter = range(len(mappedData.srcPsl.blocks))
    if mappedData.srcPsl.qStrand == '-':
        iExonIter = reversed(iExonIter)

    srcExonNum = 1
    for iSrcExon in iExonIter:
        exons.append(processExon(srcGenome, srcGenomeSeqs, mappedGenomeSeqs, srcExonNum, mappedData.srcPsl.blocks[iSrcExon],
                                 mappedData.srcGp.exons[iSrcExon], mappedData.mappedPsl, mappedData.mappedGp))
        srcExonNum += 1

    srcMeta = mappedData.srcMeta
    mappedTrans = MappedTranscript(srcGenome, mappedData.srcPsl.qName, mappedGenome, mappedData.mappedPsl.qName, pslToRCoords(mappedData.srcPsl), pslToRCoords(mappedData.mappedPsl),
                                   srcMeta.geneId, srcMeta.geneName, srcMeta.geneType, srcMeta.transcriptName, srcMeta.transcriptType,
                                   getCds(mappedData.srcGp), getCds(mappedData.mappedGp), exons)
    return mappedTrans

def mappedAlignToAnnot(srcGenome, mappedGenome, mappedDataSet):
    srcGenomeSeqs = twobitreader.TwoBitFile(getGenomeTwoBit(srcGenome))
    mappedGenomeSeqs = twobitreader.TwoBitFile(getGenomeTwoBit(mappedGenome))

    mappedAnnots = []
    for mappedData in mappedDataSet:
        mappedAnnots.append(processTrans(srcGenome, srcGenomeSeqs,
                                         mappedGenome, mappedGenomeSeqs,
                                         mappedData))
    return mappedAnnots

def writeAnnotBed(mappedAnnots, bedFh):
    for ma in mappedAnnots:
        bed = mappedTranscriptToBed(ma)
        if bed is not None:
            bed.write(bedFh)

def main(opts):
    mappedDataSet = loadMappings(opts.srcPsl, opts.srcGenePred, opts.srcMeta,
                                 opts.mappedPsl, opts.mappedGenePred)
    mappedAnnots = mappedAlignToAnnot(opts.srcGenome, opts.mappedGenome,
                                      mappedDataSet)

    with fileOps.opengz(opts.annotJson, "w") as fh:
        json.dump(mappedAnnots, fh, indent=4)

    if opts.annotBed is not None:
        with fileOps.opengz(opts.annotBed, "w") as fh:
            writeAnnotBed(mappedAnnots, fh)


main(parseArgs())
