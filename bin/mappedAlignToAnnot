#!/usr/bin/env python3
import sys
from os import path as osp
import argparse
import json
sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../lib")))

from pycbio.hgdata.psl import PslTbl, PslReader, dropQueryUniq
from pycbio.hgdata.genePred import GenePredReader
from pycbio.tsv import TsvReader
from pycbio.sys import fileOps
from xspecies.data import Range, Coords, MappedTranscript, MappedExon

# src tcoords -> mapping tcoords -> mapping qcoords -> src qcoords -> src tcoords

def parseArgs():
    usage = """Generate annotation JSON file for exchange"""
    parser = argparse.ArgumentParser(description=usage)
    parser.add_argument('srcGenome')
    parser.add_argument('srcPsl')
    parser.add_argument('srcMeta')
    parser.add_argument('mappedPsl')
    parser.add_argument('mappedGenePred')
    parser.add_argument('annotJson')
    return parser.parse_args()

def pslFindBlocksByQuery(psl, qStart, qEnd):
    "range should be is positive coordinates, return a blocks overlapping"
    blks = []
    for blk in psl.blocks:
        if (qStart < blk.qEndPlus) and (qEnd > blk.qStartPlus):
            blks.append(blk)
    return blks

def pslBlkToRange(blk):
    return Range(blk.tStart, blk.tEnd)

def pslToCoords(psl):
    return Coords(psl.tName, psl.tStart, psl.tEnd, psl.qStrand)

def mkSrcExonCoords(srcGenome, srcExon):
    return "{}.{}:{}-{}".format(srcGenome, srcExon.psl.tName, srcExon.tStart, srcExon.tEnd)

def loadMappedGp(mappedGpFile):
    return {gp.name: gp for gp in GenePredReader(mappedGpFile)}

def loadSrcMeta(srcMeta):
    return {t.transId: t for t in TsvReader(srcMeta)}

def buildMappedExon(srcGenome, srcExon, mappedBlks):
    mStart = mappedBlks[0].tStart
    mEnd = mappedBlks[-1].tEnd
    mappedBases = sum([len(b) for b in mappedBlks])
    return MappedExon(mkSrcExonCoords(srcGenome, srcExon),
                      pslBlkToRange(srcExon),
                      Range(mStart, mEnd), mappedBases)

def processExon(srcGenome, srcExon, mappedAln):
    mappedBlks = pslFindBlocksByQuery(mappedAln, srcExon.qStart, srcExon.qEnd)
    if len(mappedBlks) == 0:
        return MappedExon(mkSrcExonCoords(srcGenome, srcExon), pslBlkToRange(srcExon))
    else:
        return buildMappedExon(srcGenome, srcExon, mappedBlks)

def getCds(mappedGp):
    if mappedGp.txStart < mappedGp.txEnd:
        return Range(mappedGp.txStart, mappedGp.txEnd)
    else:
        return None

def processMapping(srcGenome, srcAlns, srcMeta, mappedAln, mappedGp):
    assert mappedAln.tStrand == '+'
    srcAln = srcAlns.getByQName(dropQueryUniq(mappedAln.qName))[0]
    exons = [processExon(srcGenome, srcExon, mappedAln) for srcExon in srcAln.blocks]
    mappedTrans = MappedTranscript(srcAln.qName, mappedAln.qName, pslToCoords(srcAln), pslToCoords(mappedAln),
                                   srcMeta.geneId, srcMeta.geneName, srcMeta.geneType, srcMeta.transcriptName, srcMeta.transcriptType,
                                   getCds(mappedGp), exons)
    return mappedTrans

def processMappings(srcGenome, srcAlns, srcMetas, mappedPslFile, mappedGps):
    return [processMapping(srcGenome, srcAlns, srcMetas[dropQueryUniq(ma.qName)],
                           ma, mappedGps[ma.qName])
            for ma in PslReader(mappedPslFile)]

def main(opts):
    srcAlns = PslTbl(opts.srcPsl, qNameIdx=True, qUniqDrop=True)
    srcMetas = loadSrcMeta(opts.srcMeta)
    mappedGps = loadMappedGp(opts.mappedGenePred)
    mappedAnnots = processMappings(opts.srcGenome, srcAlns, srcMetas, opts.mappedPsl, mappedGps)

    with fileOps.opengz(opts.annotJson, "w") as fh:
        json.dump(mappedAnnots, fh, indent=4)


main(parseArgs())
